#!/usr/bin/env node
/**
 * push-to-outlook.js
 * Reads a campaign calendar markdown file and pushes each milestone
 * to Microsoft Outlook via the Microsoft Graph API.
 *
 * Prerequisites:
 *   1. Register an app in Azure Active Directory (portal.azure.com)
 *   2. Grant Calendars.ReadWrite permission (delegated or application)
 *   3. Set MICROSOFT_GRAPH_TOKEN environment variable with a valid OAuth token
 *      (or run with --device-code flag to authenticate interactively)
 *
 * Usage:
 *   node push-to-outlook.js campaigns/f1-weekend-2026/calendar/campaign-calendar.md
 *   node push-to-outlook.js campaigns/f1-weekend-2026/calendar/campaign-calendar.md --calendar-id "AAMkAGI..."
 *   node push-to-outlook.js campaigns/f1-weekend-2026/calendar/campaign-calendar.md --dry-run
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

// â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const GRAPH_BASE = 'graph.microsoft.com';
const GRAPH_VERSION = 'v1.0';
const TOKEN = process.env.MICROSOFT_GRAPH_TOKEN;
const args = process.argv.slice(2);
const calendarFilePath = args.find(a => !a.startsWith('--'));
const calendarId = (() => { const i = args.indexOf('--calendar-id'); return i >= 0 ? args[i + 1] : null; })();
const isDryRun = args.includes('--dry-run');

if (!calendarFilePath) {
  console.error('Usage: node push-to-outlook.js <campaign-calendar.md> [--calendar-id <id>] [--dry-run]');
  process.exit(1);
}

if (!TOKEN && !isDryRun) {
  console.error('Error: MICROSOFT_GRAPH_TOKEN environment variable is not set.');
  console.error('Get a token by registering an app in Azure AD with Calendars.ReadWrite permission.');
  console.error('For development, use the --dry-run flag to preview events without pushing.');
  process.exit(1);
}

// â”€â”€â”€ Parse Calendar Markdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function parseCalendar(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');

  // Extract YAML frontmatter
  const fmMatch = content.match(/^---\n([\s\S]*?)\n---/);
  const frontmatter = {};
  if (fmMatch) {
    fmMatch[1].split('\n').forEach(line => {
      const [key, ...val] = line.split(':');
      if (key && val.length) frontmatter[key.trim()] = val.join(':').trim();
    });
  }

  const campaign = frontmatter.campaign || path.dirname(filePath).split('/')[1] || 'campaign';

  // Extract milestones: lines starting with ### ðŸ“…
  const milestonePattern = /### ðŸ“… (\d{4}-\d{2}-\d{2}|\[Date\]) â€” (.+?)\n([\s\S]*?)(?=### ðŸ“…|## |$)/g;
  const milestones = [];
  let match;

  while ((match = milestonePattern.exec(content)) !== null) {
    const dateStr = match[1];
    const title = match[2].trim();
    const body = match[3].trim();

    // Skip placeholder [Date] entries
    if (dateStr === '[Date]') continue;

    // Extract command if present
    const cmdMatch = body.match(/\*\*Command:\*\*\s*`([^`]+)`/);
    const command = cmdMatch ? cmdMatch[1] : null;

    // Extract time needed
    const timeMatch = body.match(/\*\*Time needed:\*\*\s*(.+)/);
    const timeNeeded = timeMatch ? timeMatch[1] : '1 hour';

    milestones.push({
      date: dateStr,
      title: `[${campaign}] â€” ${title}`,
      body: body,
      command: command,
      timeNeeded: timeNeeded,
    });
  }

  return { campaign, milestones };
}

// â”€â”€â”€ Build Graph API Event Payload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildEventPayload(milestone) {
  const startDate = new Date(milestone.date + 'T09:00:00');
  const endDate = new Date(milestone.date + 'T10:00:00');

  const formatDate = (d) => d.toISOString().replace('Z', '');

  const bodyContent = [
    milestone.command ? `**Command:** \`${milestone.command}\`` : '',
    '',
    milestone.body,
    '',
    '---',
    'Generated by compound-marketing /workflows:brief campaign calendar',
  ].filter(l => l !== undefined).join('\n');

  return {
    subject: milestone.title,
    body: {
      contentType: 'text',
      content: bodyContent,
    },
    start: {
      dateTime: formatDate(startDate),
      timeZone: 'UTC',
    },
    end: {
      dateTime: formatDate(endDate),
      timeZone: 'UTC',
    },
    reminderMinutesBeforeStart: 1440, // 24 hours
    isReminderOn: true,
    showAs: 'busy',
  };
}

// â”€â”€â”€ Graph API Request â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function graphRequest(method, endpoint, body) {
  return new Promise((resolve, reject) => {
    const data = body ? JSON.stringify(body) : null;
    const options = {
      hostname: GRAPH_BASE,
      path: `/${GRAPH_VERSION}/${endpoint}`,
      method,
      headers: {
        'Authorization': `Bearer ${TOKEN}`,
        'Content-Type': 'application/json',
        ...(data ? { 'Content-Length': Buffer.byteLength(data) } : {}),
      },
    };

    const req = https.request(options, (res) => {
      let responseData = '';
      res.on('data', chunk => responseData += chunk);
      res.on('end', () => {
        try {
          resolve({ status: res.statusCode, body: JSON.parse(responseData) });
        } catch {
          resolve({ status: res.statusCode, body: responseData });
        }
      });
    });

    req.on('error', reject);
    if (data) req.write(data);
    req.end();
  });
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  console.log(`Reading calendar: ${calendarFilePath}`);

  let parsed;
  try {
    parsed = parseCalendar(calendarFilePath);
  } catch (err) {
    console.error(`Failed to read calendar file: ${err.message}`);
    process.exit(1);
  }

  const { campaign, milestones } = parsed;
  console.log(`Campaign: ${campaign}`);
  console.log(`Milestones found: ${milestones.length}`);

  if (milestones.length === 0) {
    console.warn('No dated milestones found in the calendar file.');
    console.warn('Ensure milestone dates are in YYYY-MM-DD format (e.g., ### ðŸ“… 2026-03-04 â€” Ideation Session)');
    process.exit(0);
  }

  if (isDryRun) {
    console.log('\n--- DRY RUN â€” No events will be created ---\n');
    milestones.forEach((m, i) => {
      console.log(`Event ${i + 1}: ${m.title}`);
      console.log(`  Date: ${m.date} 09:00â€“10:00`);
      if (m.command) console.log(`  Command: ${m.command}`);
      console.log('');
    });
    console.log('--- End dry run ---');
    return;
  }

  // Determine calendar endpoint
  const calendarEndpoint = calendarId
    ? `me/calendars/${calendarId}/events`
    : 'me/calendar/events';

  console.log(`\nPushing to Outlook (${calendarId ? 'specified calendar' : 'default calendar'})...\n`);

  const results = [];
  for (const milestone of milestones) {
    const payload = buildEventPayload(milestone);
    process.stdout.write(`  Creating: ${milestone.title} (${milestone.date})... `);

    try {
      const result = await graphRequest('POST', calendarEndpoint, payload);
      if (result.status === 201) {
        console.log('âœ“');
        results.push({ milestone: milestone.title, status: 'created', id: result.body.id });
      } else {
        console.log(`âœ— (HTTP ${result.status})`);
        results.push({ milestone: milestone.title, status: 'failed', error: result.body });
      }
    } catch (err) {
      console.log(`âœ— (${err.message})`);
      results.push({ milestone: milestone.title, status: 'error', error: err.message });
    }

    // Brief delay to avoid rate limiting
    await new Promise(r => setTimeout(r, 200));
  }

  // Summary
  const created = results.filter(r => r.status === 'created').length;
  const failed = results.filter(r => r.status !== 'created').length;
  console.log(`\nDone. ${created} events created, ${failed} failed.`);

  if (failed > 0) {
    console.log('\nFailed events:');
    results.filter(r => r.status !== 'created').forEach(r => {
      console.log(`  - ${r.milestone}: ${JSON.stringify(r.error)}`);
    });
    process.exit(1);
  }

  // Update frontmatter outlook_synced flag
  const calendarContent = fs.readFileSync(calendarFilePath, 'utf8');
  const updated = calendarContent.replace('outlook_synced: false', 'outlook_synced: true');
  fs.writeFileSync(calendarFilePath, updated, 'utf8');
  console.log('\nUpdated campaign-calendar.md: outlook_synced: true');
}

main().catch(err => {
  console.error('Unexpected error:', err);
  process.exit(1);
});
